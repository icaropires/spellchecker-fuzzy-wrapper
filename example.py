import re
import subprocess
import json
import pickle
from typing import Iterable, Dict, Tuple, List

from tqdm import tqdm


TOKENS_FILE = "tokens.txt"
VOCAB_FILE = "vocabulary.txt"
CORRECTED_TOKENS_FILE = "corrections.pkl"


def run_spellchecker(tokens_file, vocab_file):
    # Bigger = slower, more false positives, more detailed analysis
    depth = 2

    # Spellcheck bin must be at same folder
    process = subprocess.Popen(
        ("./spellchecker", str(depth), tokens_file, vocab_file),
        stdout=subprocess.PIPE
    )

    dumps = list()
    pbar = None

    log_pat = re.compile(r'^\[[A-Z]+\]')
    total_string_start = "Total of words to be corrected = "

    print('Spellchecker outputs and progress:')
    while True:
        line = process.stdout.readline().decode('utf-8').strip()

        if not line and process.poll() is not None:
            break

        if log_pat.match(line):
            print(f'  {line}')

            if total_string_start in line.strip():
                total = int(line.split('=')[-1].strip())
                pbar = tqdm(total=total)
        elif line:
            dumps.append(line)

            if line.strip() not in ('{', '}'):
                if pbar is not None:
                    pbar.update(1)
                else:
                    print('.', end='')

    if pbar is not None:
        pbar.close()

    return ''.join(dumps)


def get_corrections(tokens_file: str, vocab_file: str) -> Tuple[Dict[str, str], List[str]]:
    dump = run_spellchecker(tokens_file, vocab_file)

    try:
        all_corrections = json.loads(dump)
    except json.decoder.JSONDecodeError:
        invalid_json_name = 'invalid_output.json'

        with open(invalid_json_name, 'w') as f:
            f.write(dump)

        raise RuntimeError(
            "An invalid json was generated by the spellchecker"
            f" and was saved to {invalid_json_name}"
        )

    corrections, unkowns = dict(), list()
    for token, correction in all_corrections.items():
        if correction:
            corrections[token] = correction
        else:
            unkowns.append(token)

    return corrections, unkowns


def correct_string(tokens: Iterable[str], corrections_dict: Dict[str, str]) -> str:
    return ' '.join(corrections_dict.get(t, '') for t in tokens)


corrections, unkowns = get_corrections(TOKENS_FILE, VOCAB_FILE)

tokens = None
with open(TOKENS_FILE, 'r') as tf:
    tokens = tf.readlines()

corrected = correct_string(tokens, corrections)

print("\nFinished! Saving results...")
with open(CORRECTED_TOKENS_FILE, 'wb') as corrected_file:
    pickle.dump(corrections, corrected_file)
print(f"Corrections dict object saved to '{CORRECTED_TOKENS_FILE}' !")

unkowns_str = "\n".join(f'  - {u}' for u in unkowns if u)

# print(f'Corrected string: {corrected}')
# if unkowns:
#     print("Tokens excluded for not being recognized:", unkowns_str, sep='\n')

unkowns_filename = 'unknowns.txt'
with open(unkowns_filename, 'w') as f:
    f.write(unkowns_str)

print(f"Words that could not be corrected saved to '{unkowns_filename}' !")
